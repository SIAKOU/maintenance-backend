'use strict';

/** 
 * @type {import('sequelize-cli').Migration} 
 * 
 * Bonnes pratiques :
 * 1. Toujours utiliser des transactions
 * 2. Vérifier l'existence des éléments avant modification
 * 3. Implémenter complètement la méthode down()
 * 4. Documenter chaque étape
 * 5. Gérer proprement les erreurs
 */
module.exports = {
  async up(queryInterface, Sequelize) {
    // Début de la transaction
    const transaction = await queryInterface.sequelize.transaction();
    
    try {
      // =============================================
      // Exemple complet pour créer une table 'products'
      // =============================================
      
      // 1. Vérifier si la table existe déjà
      const tables = await queryInterface.showAllTables();
      if (!tables.includes('products')) {
        await queryInterface.createTable('products', {
          id: {
            type: Sequelize.INTEGER,
            primaryKey: true,
            autoIncrement: true,
            allowNull: false
          },
          name: {
            type: Sequelize.STRING(100),
            allowNull: false,
            validate: {
              notEmpty: true
            }
          },
          price: {
            type: Sequelize.DECIMAL(10, 2),
            allowNull: false,
            defaultValue: 0.00
          },
          description: {
            type: Sequelize.TEXT,
            allowNull: true
          },
          category_id: {
            type: Sequelize.INTEGER,
            references: {
              model: 'categories', // suppose que la table categories existe
              key: 'id'
            },
            onUpdate: 'CASCADE',
            onDelete: 'SET NULL'
          },
          is_active: {
            type: Sequelize.BOOLEAN,
            allowNull: false,
            defaultValue: true
          },
          created_at: {
            type: Sequelize.DATE,
            allowNull: false,
            defaultValue: Sequelize.literal('CURRENT_TIMESTAMP')
          },
          updated_at: {
            type: Sequelize.DATE,
            allowNull: false,
            defaultValue: Sequelize.literal('CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP')
          }
        }, { 
          transaction,
          // Optionnel : ajout d'index
          indexes: [
            {
              unique: true,
              fields: ['name']
            },
            {
              fields: ['category_id']
            }
          ]
        });

        // 2. Ajouter un commentaire sur la table (PostgreSQL/MySQL)
        await queryInterface.sequelize.query(
          "COMMENT ON TABLE products IS 'Table des produits en stock'",
          { transaction }
        );
      }

      // =============================================
      // Exemple pour ajouter une colonne conditionnelle
      // =============================================
      const tableDescription = await queryInterface.describeTable('products');
      
      if (!tableDescription.stock_quantity) {
        await queryInterface.addColumn(
          'products',
          'stock_quantity',
          {
            type: Sequelize.INTEGER,
            allowNull: false,
            defaultValue: 0
          },
          { transaction }
        );
      }

      // Valider la transaction
      await transaction.commit();
    } catch (error) {
      // Annuler en cas d'erreur
      await transaction.rollback();
      throw error;
    }
  },

  async down(queryInterface, Sequelize) {
    // Toujours implémenter un rollback sécurisé
    const transaction = await queryInterface.sequelize.transaction();
    
    try {
      // 1. Supprimer la colonne si elle existe
      const tableDescription = await queryInterface.describeTable('products');
      
      if (tableDescription.stock_quantity) {
        await queryInterface.removeColumn(
          'products', 
          'stock_quantity', 
          { transaction }
        );
      }

      // 2. Supprimer la table (optionnel - à utiliser avec prudence)
      // await queryInterface.dropTable('products', { transaction });

      await transaction.commit();
    } catch (error) {
      await transaction.rollback();
      throw error;
    }
  }
};